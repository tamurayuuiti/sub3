<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>五目並べ — PvP 勝率解析（Threat-Space + Negamax）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    :root{--card-bg:#fff;--board-bg:#e0b468}
    body { font-family: 'Inter', sans-serif; background:#f3f4f6; padding:20px; }
    .board-grid { display: grid; grid-template-columns: repeat(15, minmax(0, 1fr)); grid-template-rows: repeat(15, minmax(0, 1fr)); border: 2px solid #333; background:var(--board-bg); box-shadow:0 8px 20px rgba(0,0,0,0.18); aspect-ratio:1/1; width:100%; max-width:640px; }
    .cell { position:relative; cursor:pointer; width:100%; padding-bottom:100%; }
    .cell::before { content: ''; position:absolute; top:0; left:0; width:100%; height:100%; border-right:1px solid #333; border-bottom:1px solid #333; box-sizing:border-box; }
    .board-grid > div:nth-child(15n)::before { border-right:none; }
    .board-grid > div:nth-child(n):nth-last-child(-n+15)::before { border-bottom:none; }
    .stone { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:80%; height:80%; border-radius:50%; box-shadow:0 1px 3px rgba(0,0,0,0.35); pointer-events:none; transition:transform .08s ease-out; }
    .stone-black{ background:#111; } .stone-white{ background:#fff; border:1px solid #333; }
    .thinking { display:flex; align-items:center; gap:8px; justify-content:center; }
    .dot{ width:8px; height:8px; background:#4f46e5; border-radius:999px; animation:b 1.4s infinite ease-in-out; }
    .dot:nth-child(1){ animation-delay:-0.32s } .dot:nth-child(2){ animation-delay:-0.16s } @keyframes b{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
    .stat-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px; }
    .control { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .small { font-size:13px; }
    .disabled-overlay { position:absolute; inset:0; background:rgba(255,255,255,0.6); display:flex; align-items:center; justify-content:center; z-index:50; }
    @media (max-width: 900px) { .flex-row-sm { flex-direction: column; } }
  </style>
</head>
<body>
  <div class="max-w-6xl mx-auto">
    <div class="bg-white p-6 rounded-xl shadow-lg relative">
      <h1 class="text-2xl font-bold text-center mb-4">五目並べ — PvP 勝率解析（Threat-Space + Negamax）</h1>

      <div class="flex gap-4 flex-col lg:flex-row">
        <!-- 左：盤・操作 -->
        <div class="w-full lg:w-2/3">
          <div class="flex items-center justify-between mb-3">
            <div class="flex gap-2">
              <button id="select-black" class="px-3 py-2 bg-sky-600 text-white rounded-lg font-semibold">先手（黒）</button>
              <button id="select-white" class="px-3 py-2 bg-gray-200 rounded-lg">先手を白にする</button>
              <button id="clearBoard" class="px-3 py-2 bg-gray-100 rounded-lg">盤をクリア</button>
            </div>
            <div class="small text-gray-600">解析方式: <span class="font-semibold">Threat-Space + Negamax</span></div>
          </div>

          <div id="game-container" class="p-4 bg-white rounded-lg border relative">
            <div id="message" class="mb-3 p-2 rounded text-center bg-indigo-50 text-indigo-700 font-semibold">先手（黒）を選んで開始してください。</div>

            <div id="board" class="board-grid mx-auto rounded-lg" aria-label="五目並べ盤"></div>

            <!-- 解析操作 -->
            <div class="mt-4 flex gap-2 items-center">
              <button id="undo" class="px-4 py-2 bg-gray-200 rounded-full">取り消し（1手）</button>
              <div class="ml-auto flex items-center gap-2">
                <button id="computeProbBtn" class="px-3 py-2 bg-amber-500 text-white rounded-lg small">手動で解析</button>
                <button id="autoToggle" class="px-3 py-2 bg-green-100 rounded-lg small">自動解析：ON</button>
                <div class="small text-gray-600">盤: 15×15</div>
              </div>
            </div>

            <!-- 解析中オーバーレイ（自動で表示・非表示） -->
            <div id="overlay" class="disabled-overlay" style="display:none;">
              <div class="text-center">
                <div class="thinking mb-2"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
                <div class="text-sm font-medium text-gray-700">解析中 — 完了するまで操作は無効化されています</div>
              </div>
            </div>
          </div>
        </div>

        <!-- 右：設定・統計 -->
        <div class="w-full lg:w-1/3">
          <div class="mb-3 p-4 rounded-lg bg-gray-50 border">
            <div class="flex items-center justify-between mb-2">
              <div class="font-semibold">解析パラメータ</div>
              <div class="small text-gray-500">応答時間と精度のトレードオフ</div>
            </div>

            <div class="mt-2 small">
              <label class="block mb-1">候補半径: <span id="radiusLabel">2</span></label>
              <input id="radius" type="range" min="1" max="4" value="2" class="w-full" />
            </div>

            <div class="mt-2 small">
              <label class="block mb-1">思考時間／手（ms）: <span id="timeLabel">1200</span> ms</label>
              <input id="time" type="range" min="100" max="5000" step="100" value="1200" class="w-full" />
            </div>

            <div class="mt-2 small">
              <label class="block mb-1">最低探索深度: <span id="minDepthLabel">3</span></label>
              <input id="minDepth" type="range" min="1" max="12" step="1" value="3" class="w-full" />
            </div>

            <hr class="my-3" />

            <div class="mt-1 small">
              <label class="block mb-1 font-medium">勝率解析設定</label>
              <div class="flex gap-2 items-center mb-2">
                <label class="small text-gray-600">評価→勝率スケール:</label>
                <input id="probScale" type="number" min="1" step="1" value="2000000" class="border rounded px-2 py-1 w-36" />
              </div>
              <div class="flex items-center gap-2 mb-2">
                <input id="computeBoth" type="checkbox" />
                <label for="computeBoth" class="small text-gray-700">両視点で評価（時間 ≒ 2倍）</label>
              </div>
              <p class="mt-1 small text-gray-500">評価値をシグモイドで確率化します。scale を小さくすると差が敏感になります。</p>
            </div>

            <div class="mt-3 control">
              <button id="showParams" class="ml-auto px-2 py-1 bg-sky-100 rounded">現在値を表示</button>
            </div>
          </div>

          <div class="mb-3 p-4 rounded-lg bg-white border">
            <div class="flex items-center justify-between mb-2">
              <div class="font-semibold">解析統計（リアルタイム）</div>
              <div class="small text-gray-500">最新の進捗</div>
            </div>

            <div class="stat-grid text-sm">
              <div class="p-2 rounded border"><div class="small text-gray-500">達成深度</div><div id="stat-depth" class="font-medium">0</div></div>
              <div class="p-2 rounded border"><div class="small text-gray-500">経過時間</div><div id="stat-time" class="font-medium">0 ms</div></div>
              <div class="p-2 rounded border"><div class="small text-gray-500">探索ノード数</div><div id="stat-nodes" class="font-medium">0</div></div>
              <div class="p-2 rounded border"><div class="small text-gray-500">ノード／秒</div><div id="stat-nps" class="font-medium">0</div></div>
              <div class="p-2 rounded border"><div class="small text-gray-500">最良候補</div><div id="stat-candidates" class="font-medium">—</div></div>
              <div class="p-2 rounded border"><div class="small text-gray-500">評価（表示）</div><div id="stat-eval" class="font-medium">—</div></div>
            </div>

            <div id="cpuLog" class="mt-3 text-xs text-gray-600 h-28 overflow-auto bg-gray-50 p-2 rounded"></div>
          </div>

          <div id="probChartContainer" class="p-4 bg-white border rounded-lg text-center">
            <!-- 勝率円グラフをここに描画 -->
            <div id="probChartInner"></div>
          </div>
        </div>
      </div>

      <div class="mt-6 small text-gray-500 text-center">局面の勝率は探索評価に基づく近似です。深さや設定で値が変わります。</div>
    </div>
  </div>

  <!-- パラメータモーダル -->
  <div id="paramsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
    <div class="bg-white rounded-lg p-6 shadow-xl max-w-sm w-full">
      <h3 class="text-lg font-bold mb-4">現在の解析パラメータ</h3>
      <div id="paramsDetails" class="space-y-2 text-sm"></div>
      <button id="closeModal" class="mt-4 w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">閉じる</button>
    </div>
  </div>

  <!-- メインスクリプト（この HTML 単体で動きます） -->
  <script>
  // === 定数・状態 ===
  const BOARD_SIZE = 15;
  const EMPTY = 0, BLACK = 1, WHITE = 2;

  let board = [];
  let currentPlayer = BLACK;
  let startSide = BLACK;
  let gameOver = true;
  let history = [];

  // 解析設定（UI で変更可能）
  window.aiSettings = {
    radius: 2,
    timeLimit: 1200,
    minDepth: 3,
    probScale: 2000000,
    computeBoth: false
  };

  let aiWorker = null;
  let computing = false;
  let autoCompute = true; // 自動解析モード（石を置いたら自動で解析）

  // DOM キャッシュ
  const dom = {};
  document.addEventListener('DOMContentLoaded', init);

  function init(){
    // cache
    dom.board = document.getElementById('board');
    dom.message = document.getElementById('message');
    dom.selectBlack = document.getElementById('select-black');
    dom.selectWhite = document.getElementById('select-white');
    dom.clearBoard = document.getElementById('clearBoard');
    dom.reset = document.getElementById('reset');
    dom.undo = document.getElementById('undo');
    dom.radius = document.getElementById('radius');
    dom.radiusLabel = document.getElementById('radiusLabel');
    dom.time = document.getElementById('time');
    dom.timeLabel = document.getElementById('timeLabel');
    dom.minDepth = document.getElementById('minDepth');
    dom.minDepthLabel = document.getElementById('minDepthLabel');
    dom.probScale = document.getElementById('probScale');
    dom.computeBoth = document.getElementById('computeBoth');
    dom.computeProbBtn = document.getElementById('computeProbBtn');
    dom.autoToggle = document.getElementById('autoToggle');
    dom.showParams = document.getElementById('showParams');
    dom.paramsModal = document.getElementById('paramsModal');
    dom.paramsDetails = document.getElementById('paramsDetails');
    dom.closeModal = document.getElementById('closeModal');
    dom.overlay = document.getElementById('overlay');
    dom.statDepth = document.getElementById('stat-depth');
    dom.statTime = document.getElementById('stat-time');
    dom.statNodes = document.getElementById('stat-nodes');
    dom.statNps = document.getElementById('stat-nps');
    dom.statCandidates = document.getElementById('stat-candidates');
    dom.statEval = document.getElementById('stat-eval');
    dom.cpuLog = document.getElementById('cpuLog');
    dom.probChartContainer = document.getElementById('probChartInner');

    // board 作成・イベント登録
    createBoard();
    bindUI();
    startGame(startSide);
  }

  function createBoard(){
    dom.board.innerHTML = '';
    for(let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = i;
      cell.addEventListener('click', handleCellClick);
      dom.board.appendChild(cell);
    }
  }

  function bindUI(){
    dom.selectBlack.addEventListener('click', ()=> startGame(BLACK));
    dom.selectWhite.addEventListener('click', ()=> startGame(WHITE));
    dom.clearBoard.addEventListener('click', resetGame);
    dom.undo.addEventListener('click', ()=> {
      if (computing) { logToCPU('解析中は取り消せません。','error'); return; }
      undoMove();
    });

    dom.radius.addEventListener('input', e => { aiSettings.radius = parseInt(e.target.value,10); dom.radiusLabel.textContent = e.target.value; });
    dom.time.addEventListener('input', e => { aiSettings.timeLimit = parseInt(e.target.value,10); dom.timeLabel.textContent = e.target.value + ' ms'; });
    dom.minDepth.addEventListener('input', e => { aiSettings.minDepth = Math.max(1, parseInt(e.target.value,10)); dom.minDepthLabel.textContent = e.target.value; });
    dom.probScale.addEventListener('change', e => { aiSettings.probScale = Math.max(1, Number(e.target.value)||1); });
    dom.computeBoth.addEventListener('change', e => { aiSettings.computeBoth = !!e.target.checked; });

    dom.computeProbBtn.addEventListener('click', ()=> {
      if (computing) { logToCPU('既に解析中です。','error'); return; }
      startComputeWithBlock();
    });

    dom.autoToggle.addEventListener('click', ()=> {
      autoCompute = !autoCompute;
      dom.autoToggle.textContent = `自動解析：${autoCompute ? 'ON' : 'OFF'}`;
      logToCPU(`自動解析を${autoCompute ? '有効' : '無効'}にしました。`);
    });

    dom.showParams.addEventListener('click', showParameters);
    dom.closeModal.addEventListener('click', ()=> dom.paramsModal.classList.add('hidden'));
    dom.paramsModal.addEventListener('click', (e)=> { if(e.target===dom.paramsModal) dom.paramsModal.classList.add('hidden'); });
  }

  function startGame(color){
    startSide = color;
    board = Array.from({length:BOARD_SIZE}, ()=> Array(BOARD_SIZE).fill(EMPTY));
    history = [];
    gameOver = false;
    currentPlayer = startSide;
    drawBoard();
    resetStats();
    updateMessage((currentPlayer===BLACK ? '黒' : '白') + 'の番です。');
    // toggle buttons style
    dom.selectBlack.classList.toggle('bg-sky-600', startSide===BLACK);
    dom.selectBlack.classList.toggle('text-white', startSide===BLACK);
    dom.selectWhite.classList.toggle('bg-sky-600', startSide===WHITE);
    dom.selectWhite.classList.toggle('text-white', startSide===WHITE);
  }

  function resetGame(){
    if (computing) { logToCPU('解析中はリセットできません。','error'); return; }
    startGame(startSide);
    clearProbChart();
  }

  function resetStats(){
    dom.statDepth.textContent='0';
    dom.statTime.textContent='0 ms';
    dom.statNodes.textContent='0';
    dom.statNps.textContent='0';
    dom.statCandidates.textContent='—';
    dom.statEval.textContent='—';
    dom.cpuLog.innerHTML='';
  }

  function handleCellClick(e){
    if (gameOver || computing) { if(computing) logToCPU('解析中は石を置けません。','error'); return; }
    const cell = e.target.closest('.cell');
    if (!cell) return;
    const idx = Number(cell.dataset.index);
    const x = idx % BOARD_SIZE, y = Math.floor(idx / BOARD_SIZE);
    if (board[y][x] !== EMPTY) return;
    placeStone(x,y,currentPlayer);
    if (autoCompute) startComputeWithBlock();
  }

  function placeStone(x,y,player){
    if (gameOver || computing) return;
    board[y][x] = player;
    history.push({x,y,player});
    drawBoard();
    if (checkWin(x,y,player)){
      gameOver = true;
      updateMessage((player===BLACK? '黒':'白') + 'の勝ちです！','success');
      clearProbChart();
      return;
    }
    currentPlayer = (player===BLACK? WHITE: BLACK);
    updateMessage((currentPlayer===BLACK? '黒':'白') + 'の番です。');
  }

  function undoMove(){
    if (history.length === 0) { logToCPU('取り消せる手がありません。','error'); return; }
    const last = history.pop();
    board[last.y][last.x] = EMPTY;
    currentPlayer = last.player;
    drawBoard();
    updateMessage((currentPlayer===BLACK? '黒':'白') + 'の番です（1手を取り消しました）。');
  }

  function checkWin(x,y,player){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      let cnt = 1;
      for(let i=1;i<5;i++){ const nx=x+i*dx, ny=y+i*dy; if(nx>=0&&nx<BOARD_SIZE&&ny>=0&&ny<BOARD_SIZE&&board[ny][nx]===player) cnt++; else break; }
      for(let i=1;i<5;i++){ const nx=x-i*dx, ny=y-i*dy; if(nx>=0&&nx<BOARD_SIZE&&ny>=0&&ny<BOARD_SIZE&&board[ny][nx]===player) cnt++; else break; }
      if (cnt>=5) return true;
    }
    return false;
  }

  function drawBoard(){
    dom.board.querySelectorAll('.cell').forEach((cell)=> {
      const idx = Number(cell.dataset.index);
      const x = idx % BOARD_SIZE, y = Math.floor(idx / BOARD_SIZE);
      const existing = cell.querySelector('.stone');
      if (existing) existing.remove();
      if (board[y][x] !== EMPTY){
        const st = document.createElement('div');
        st.className = 'stone ' + (board[y][x]===BLACK? 'stone-black':'stone-white');
        cell.appendChild(st);
      }
    });
  }

  function updateMessage(msg, type='info'){
    dom.message.textContent = msg;
    dom.message.className = 'mb-3 p-2 rounded text-center font-semibold';
    if (type==='thinking'){
      dom.message.innerHTML = `<div class="thinking">${msg}<div class="dot"></div><div class="dot"></div><div class="dot"></div></div>`;
      dom.message.classList.add('bg-yellow-50','text-yellow-700');
    } else if (type==='success'){
      dom.message.classList.add('bg-green-50','text-green-700');
    } else if (type==='error'){
      dom.message.classList.add('bg-red-50','text-red-700');
    } else {
      dom.message.classList.add('bg-indigo-50','text-indigo-700');
    }
  }

  function logToCPU(message, type='info'){
    const p = document.createElement('p');
    if (type==='eval') p.classList.add('text-sky-700','font-semibold');
    p.textContent = message;
    dom.cpuLog.appendChild(p);
    dom.cpuLog.scrollTop = dom.cpuLog.scrollHeight;
  }

  function showParameters(){
    dom.paramsDetails.innerHTML = `
      <p><strong>候補半径:</strong> ${aiSettings.radius}</p>
      <p><strong>思考時間/手:</strong> ${aiSettings.timeLimit} ms</p>
      <p><strong>最低探索深度:</strong> ${aiSettings.minDepth}</p>
      <p><strong>評価→勝率スケール:</strong> ${aiSettings.probScale}</p>
      <p><strong>両視点で評価:</strong> ${aiSettings.computeBoth ? '有効' : '無効'}</p>
    `;
    dom.paramsModal.classList.remove('hidden');
    dom.paramsModal.classList.add('flex');
  }

  /* === 勝率解析ワークフロー === */
  function startComputeWithBlock(){
    if (computing) return;
    computing = true;
    // ブロック表示
    dom.overlay.style.display = 'flex';
    // disable some buttons
    dom.computeProbBtn.disabled = true;
    dom.undo.disabled = true;
    dom.clearBoard.disabled = true;
    dom.selectBlack.disabled = true;
    dom.selectWhite.disabled = true;

    // sync settings with UI
    aiSettings.radius = Number(dom.radius.value) || aiSettings.radius;
    aiSettings.timeLimit = Number(dom.time.value) || aiSettings.timeLimit;
    aiSettings.minDepth = Number(dom.minDepth.value) || aiSettings.minDepth;
    aiSettings.probScale = Math.max(1, Number(dom.probScale.value) || aiSettings.probScale);
    aiSettings.computeBoth = !!dom.computeBoth.checked;

    updateMessage('解析中... 終了まで操作はできません', 'thinking');
    computeWinProb();
  }

  // computeWinProb -> worker 呼び出し
  function computeWinProb(){
    terminateAIWorker();
    resetStats();

    try {
      aiWorker = new Worker('./aiWorker.js', { type: 'module' });
    } catch(err) {
      console.warn('Module worker を生成できません:', err);
      try { aiWorker = new Worker('./aiWorker.js'); } catch(e) { aiWorker = null; }
      if (!aiWorker) { updateMessage('ワーカー起動に失敗しました','error'); finalizeComputeFailure(); return; }
    }

    aiWorker.onmessage = (ev) => {
      const data = ev.data;
      if (data.cmd === 'progress') {
        if (data.depth !== undefined) dom.statDepth.textContent = String(data.depth);
        if (data.elapsed !== undefined) dom.statTime.textContent = `${Math.round(data.elapsed)} ms`;
        if (data.nodes !== undefined) dom.statNodes.textContent = String(data.nodes);
        if (data.nps !== undefined) dom.statNps.textContent = String(Math.round(data.nps));
        if (data.candidate !== undefined) dom.statCandidates.textContent = data.candidate;
        if (data.eval !== undefined) dom.statEval.textContent = String(Math.round(data.eval));
        if (data.log) logToCPU(data.log);
      } else if (data.cmd === 'result') {
        if (data.mode === 'pvpProb' || (typeof data.probBlack === 'number')) {
          const pb = Number(data.probBlack) || 0;
          const pw = Number(data.probWhite) || (1-pb);
          const evalB = data.evalBlack !== undefined ? data.evalBlack : (data.eval || 0);
          const msg = `勝率（推定） — 黒: ${(pb*100).toFixed(1)}% ／ 白: ${(pw*100).toFixed(1)}% (評価=${Math.round(evalB)})`;
          updateMessage(msg);
          logToCPU(msg,'eval');
          drawProbChart(pb,pw);
        } else {
          logToCPU('未知の結果形式: ' + JSON.stringify(data), 'error');
          updateMessage('解析結果の形式が不明です', 'error');
        }
        finalizeComputeSuccess();
      } else if (data.cmd === 'error') {
        logToCPU('Worker error: ' + data.message, 'error');
        updateMessage('ワーカーでエラーが発生しました', 'error');
        finalizeComputeFailure();
      }
    };

    aiWorker.onerror = (err) => {
      console.error('Worker onerror', err);
      logToCPU('Worker でエラーが発生しました（詳細はコンソール）','error');
      updateMessage('ワーカーでエラー', 'error');
      finalizeComputeFailure();
    };

    // payload
    const payload = {
      cmd: 'think',
      board: board,
      settings: {
        mode: 'pvpProb',
        radius: aiSettings.radius,
        timeLimit: aiSettings.timeLimit,
        minDepth: aiSettings.minDepth,
        probScale: aiSettings.probScale,
        computeBoth: aiSettings.computeBoth
      },
      history: history
    };
    aiWorker.postMessage(payload);
  }

  function finalizeComputeSuccess(){
    computing = false;
    dom.overlay.style.display = 'none';
    dom.computeProbBtn.disabled = false;
    dom.undo.disabled = false;
    dom.clearBoard.disabled = false;
    dom.selectBlack.disabled = false;
    dom.selectWhite.disabled = false;
    terminateAIWorker();
  }
  function finalizeComputeFailure(){
    computing = false;
    dom.overlay.style.display = 'none';
    dom.computeProbBtn.disabled = false;
    dom.undo.disabled = false;
    dom.clearBoard.disabled = false;
    dom.selectBlack.disabled = false;
    dom.selectWhite.disabled = false;
    terminateAIWorker();
  }

  function terminateAIWorker(){
    if (aiWorker) {
      try { aiWorker.terminate(); } catch(e){}
      aiWorker = null;
    }
  }

  /* === 円グラフの描画（簡易SVG） === */
  function clearProbChart(){ dom.probChartContainer.innerHTML = ''; }
  function drawProbChart(probBlack, probWhite){
    clearProbChart();
    probBlack = Math.max(0, Math.min(1, probBlack||0));
    probWhite = Math.max(0, Math.min(1, probWhite||0));
    const size = 160, cx = size/2, cy = size/2, r = size/2-6;
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width',size); svg.setAttribute('height', size); svg.setAttribute('viewBox',`0 0 ${size} ${size}`);
    svg.style.display = 'block'; svg.style.margin = '0 auto';

    function polarToCartesian(cx,cy,r,ang){ const a=(ang-90)*Math.PI/180; return {x:cx+r*Math.cos(a), y:cy+r*Math.sin(a)}; }
    function describeArc(cx,cy,r,start, end){
      const s = polarToCartesian(cx,cy,r,end);
      const e = polarToCartesian(cx,cy,r,start);
      const large = end-start <= 180 ? '0' : '1';
      return `M ${cx} ${cy} L ${s.x} ${s.y} A ${r} ${r} 0 ${large} 0 ${e.x} ${e.y} Z`;
    }

    const angleB = probBlack*360;
    const pB = document.createElementNS(svgNS,'path'); pB.setAttribute('d', describeArc(cx,cy,r,0,angleB)); pB.setAttribute('fill','#111');
    const pW = document.createElementNS(svgNS,'path'); pW.setAttribute('d', describeArc(cx,cy,r,angleB, angleB + probWhite*360)); pW.setAttribute('fill','#fff'); pW.setAttribute('stroke','#333');
    svg.appendChild(pB); svg.appendChild(pW);

    const donut = document.createElementNS(svgNS,'circle'); donut.setAttribute('cx',cx); donut.setAttribute('cy',cy); donut.setAttribute('r', Math.max(0,r-28)); donut.setAttribute('fill','#fff'); svg.appendChild(donut);

    const text = document.createElementNS(svgNS,'text'); text.setAttribute('x',cx); text.setAttribute('y',cy); text.setAttribute('text-anchor','middle'); text.setAttribute('dominant-baseline','middle'); text.setAttribute('font-size','12'); text.setAttribute('font-weight','600');
    text.textContent = `${(probBlack*100).toFixed(1)}% / ${(probWhite*100).toFixed(1)}%`; svg.appendChild(text);

    const legend = document.createElement('div'); legend.style.display='flex'; legend.style.justifyContent='center'; legend.style.gap='12px'; legend.style.marginTop='8px'; legend.style.fontSize='13px';
    const lb = document.createElement('div'); lb.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:#111;margin-right:6px;vertical-align:middle;"></span>黒 ${(probBlack*100).toFixed(1)}%`;
    const lw = document.createElement('div'); lw.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:#fff;border:1px solid #333;margin-right:6px;vertical-align:middle;"></span>白 ${(probWhite*100).toFixed(1)}%`;

    dom.probChartContainer.appendChild(svg);
    dom.probChartContainer.appendChild(legend);
    legend.appendChild(lb); legend.appendChild(lw);
  }

  </script>
</body>
</html>
